# RestaurantOrderManager

Rest API разработано с помощью Spring Boot + Spring Web. В приложении используется БД PostgreSql и Swagger для документирования.

Веб сервер развёртывается на порте 8080. БД развёртывается с помощью докера на порте 5432 (Для этого используется зависимость docker starter для spring boot).
Если эти порты заняты, то их можно поменять в настройках приложения (об этом далее). Если проблемы с докером (иногда на Windows), то надо развернуть базу вручную и поменять соответствующие настройки приложения.
Если порт 5432 занят, то можно в docker compose поменять первое число у - '5432:5432'. 

Настроить приложение можно в application.properties. Там настраивается соответсвующий url к БД (url, имя базы, пользователь, пароль).
Про остальные настройки будет сказано далее.

После запуска приложения в консоль печатается URL, по которому можно зайти на Swagger, для тестирования кода.
Краткое описание endpoint'ов написано, а также доступны схемы всех используемых классов dto. Без авторизации доступны endpoint'ы только контроллера авторизации. Для остальных endpoint'ов будет кидаться 401 ошибка без авторизации.

При авторизации можно указать логин и пароль (на них есть ограничения, можно посмотреть в схеме или коде), а также секретный ключ (настраивается в настройках приложения, по умолчанию "secret"), который позволяет получить админку.
Далее нужно залогиниться. При успешной авторизации доступны все endpoint'ы, кроме тех, где есть пометка [ADMIN] в описании, при попытке доступа к ним обычному пользователю кинется ошибка.
После авторизации также можно и выйти через logout. Пароль шифруется MD5 хешированием.

Токен авторизации хранится в cookie, имя cookie настраивается в настройках приложения, как и длительность действительности токена. (по умолчанию Authentication и час)
В токене хранится username пользователя. Токен шифруется секретным ключом, настраиваемым в настройках приложения. 

Далее реализован весь функционал описанный в заданиях ДЗ2 (включая на оценку 10).
Из интересного: симуляция обработки заказа происходит в многопоточном режиме, для каждого заказа выделяется отдельный поток, который засыпает на время общей суммарной готовки всех блюд в заказе.
Причём потоков всего 5 (симуляция ограничения поваров), это число можно настроить в настройках приложения. Для этого механизма используется ExecutorService с ограничением потоков, причём для приоритизации заказов используется очередь, т.е. если заняты все потоки, то заказы добавляются в очередь потоков, и первый освободившийся поток принимает первый поступивший заказ.  
Время для блюд указывается в МИНУТАХ, поэтому для ускорения тестирования считаем, что в минуте 1000 миллисекунд, это число можно изменить в настройках приложения и поставить настоящее величину для полной симуляции. 

Все ошибки ловятся через глобальный класс обработки ошибок, используя @ExceptionHandler и оборачиваются в специальный кастомный класс ApiResponse.
Который хранит всё информацию об ошибке.

Для того, чтобы не пускать не авторизированных пользователей к endpoint'ам функционала, используется фильтр, который пускает не авторизированных пользователей только публичным endpoint'ам, которые можно настраивать в настройках приложения.
Swagger тоже добавлен туда. Может быть swagger будет подтягивать какие-то другие файлы при открытии с других браузеров (тестировалось на Safari), их можно добавить в этот список.

Какая статистика считается понятно по названиям полей. Стоит отметить, что в статистике учитываются только оплаченные заказы.

Используемые шаблоны проектирования:
Repository для взаимодействия с бд
Dependency Injection для проектирования Api
Chain of responsibility для авторизационного фильтра

По вопросам тг: @aubhona